---
title: "Logistic Regression"
format: gfm
---

## Case Overview

As a data analyst at MarketStar, you are tasked with running a lead qualification program as part of the sales efforts for an electronics company. The client will send over leads from various sources such as trade shows, online website hits, etc. and the MarketStar sales team works to convert the leads into qualified opportunities. This client runs B2B sales, meaning the sales reps on your team reach out to companies to see if they want to purchase electronics at scale. Once leads are qualified, the lead gets passed back to the client to close the sale.

If a lead is converted into a qualified opportunity and then closes, the sales team earns a $1,000 commission on the sale. However, if a lead is not not converted to a qualified opportunity, the sales rep wastes time and resources trying to convert the lead, which is an additional $500 opportunity cost in addition to the lost commission. There are too many leads for the sales reps to try and convert them all in the time allotted. For the sales effort to be successful, your task is to identify and help your sales reps work on converting leads that are likely to be qualified.



Transaction data from a one-week peanut butter soft launch test in a single designated market area (DMA). Each of the 4,793 rows represents one customer's peanut butter category purchase behavior during the test period.



## Data Dictionary

Sales leads data for B2B electronic sales. Each of the ______ rows represents one lead.

- **Stage**: Progress through the sales development pipeline
- **Industry**: The type of product or service the business provides
- **Employees**: The size of company based on the number of employees
- **TimeZone**: The Leadâ€™s time zone
- **LeadSource**: The source of the data for the Lead
- **days_elapsed**: Number of days elapsed since Lead creation
- **created_quarter**: Quarter of the Lead creation
- **contact_quarter**: Quarter when the Lead was first contacted
- **latest_quarter**: Quarter when the Lead was last contacted
- **EmployeeId**: Unique ID for the sales rep assigned to the Lead
- **ActivityTypeEmail**: Indicator of email contact with the Lead
- **ActivityTypePhone Call**: Indicator of call contact with the Lead
- **ActivityTypeEmail Response**: Indicator of email response with the Lead
- **ActivityTypeMeeting**: Indicator of meeting with the Lead
- **ActivityTypeLead Handraise**: Indicator of Lead requesting information
- **ActivityTypeWeb Schedule**: Indicator of Lead scheduling an appointment
- **Amount**: Estimate of how much the Lead is worth if closed

```{python}
#| eval: false
#| echo: true

import os
import polars as pl
import polars.selectors as cs
import seaborn.objects as so
import statsmodels.formula.api as smf
import bambi as bmb
import arviz as az

# Import data
leads = (pl.read_parquet(os.path.join('data', 'original_leads.parquet'))
    .select(['Stage', 'Industry', 'Employees', 'TimeZone', 'LeadSource',
        'days_elapsed', 'created_quarter', 'contact_quarter', 'latest_quarter',
        'EmployeeId', cs.starts_with('ActivityType'), 'Amount'])
    .select(pl.exclude(['ActivityTypeAbandon']))
    # .filter(pl.col('Stage') != 'Disqualified')
)

# Write data frames
leads.write_parquet(os.path.join('data', 'leads.parquet'))

# (leads
#     .group_by(pl.col('Amount'))
#     .agg(n = pl.len())
# )

# # Preprocess data
# lm_data = pb_data.to_dummies(
#     # Dummy code brand
#     columns = ['brand'], drop_first = True
# ).with_columns(
#     # Log units and price
#     (pl.col('units').fill_nan(0) + 1).log().alias('log_units'),
#     (pl.col('price') + 1).log().alias('log_price')
# ).select(
#     ['log_units', 'log_price', 'brand_Skippy', 'brand_PeterPan', 'brand_Harmons']
# ).to_pandas()

# # Fit a frequentist linear regression
# fr_fit = smf.ols('log_units ~ log_price + brand_Skippy + brand_PeterPan + brand_Harmons', data = lm_data).fit()

# # Fit a Bayesian linear regression
# ba_fit = bmb.Model('log_units ~ log_price + brand_Skippy + brand_PeterPan + brand_Harmons', data = lm_data).fit()
```

